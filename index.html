<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACTFL 3D Proficiency Pyramid ‚Äî SDC Long Sequence</title>
<style>
  :root {
    --bg0:#0b1020;
    --bg1:#0f1630;
    --card:rgba(255,255,255,.06);
    --card2:rgba(255,255,255,.08);
    --line:rgba(255,255,255,.12);
    --text:rgba(255,255,255,.92);
    --muted:rgba(255,255,255,.70);
    --muted2:rgba(255,255,255,.55);
    --accent:#7dd3fc;
    --good:#22c55e;
    --warn:#f59e0b;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    color:var(--text);
    background: radial-gradient(1200px 700px at 30% 20%, #182451 0%, var(--bg0) 55%, #070a14 100%);
  }
  .shell{
    max-width: 1280px;
    margin: 0 auto;
    padding: 18px 16px 24px;
  }
  .grid{
    display:grid;
    grid-template-columns: 1.35fr 1fr;
    gap: 16px;
    align-items: stretch;
  }
  @media (max-width: 980px){
    .grid{grid-template-columns:1fr;}
  }
  .card{
    background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
    border:1px solid var(--line);
    border-radius: 18px;
    box-shadow: 0 20px 50px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .topbar{
    padding: 12px 14px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    border-bottom:1px solid var(--line);
    background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.02));
  }
  select, button{
    appearance:none;
    border:1px solid var(--line);
    background: rgba(0,0,0,.25);
    color: var(--text);
    padding: 10px 12px;
    border-radius: 12px;
    font-size: 14px;
    outline:none;
  }
  select{
    padding-right: 34px;
    background-image:
      linear-gradient(45deg, transparent 50%, rgba(255,255,255,.75) 50%),
      linear-gradient(135deg, rgba(255,255,255,.75) 50%, transparent 50%),
      linear-gradient(to right, transparent, transparent);
    background-position:
      calc(100% - 16px) 50%,
      calc(100% - 10px) 50%,
      100% 0;
    background-size: 6px 6px, 6px 6px, 2.6em 2.6em;
    background-repeat: no-repeat;
  }
  button{
    cursor:pointer;
  }
  button:hover{border-color: rgba(255,255,255,.25)}
  .hint{
    color:var(--muted2);
    font-size: 12px;
    margin-left:auto;
  }
  .viewer{
    position: relative;
    height: 520px;
  }
  @media (max-width: 980px){
    .viewer{height: 440px;}
  }
  canvas{display:block; width:100%; height:100%;}
  .overlayBadge{
    position:absolute;
    left:12px;
    bottom:12px;
    font-size: 12px;
    color: var(--muted);
    background: rgba(0,0,0,.35);
    border:1px solid var(--line);
    border-radius: 12px;
    padding: 8px 10px;
    backdrop-filter: blur(8px);
  }
  .panel{
    padding: 16px;
    display:flex;
    flex-direction:column;
    gap: 12px;
  }
  h1{
    margin:0;
    font-size: 20px;
    letter-spacing: .2px;
  }
  .sub{
    margin-top:-6px;
    color:var(--muted);
    font-size: 13px;
    line-height: 1.35;
  }
  .chips{
    display:flex;
    flex-wrap:wrap;
    gap: 8px;
  }
  .chip{
    font-size: 12px;
    color: var(--muted);
    border:1px solid var(--line);
    background: rgba(0,0,0,.22);
    padding: 7px 10px;
    border-radius: 999px;
  }
  .section{
    border:1px solid var(--line);
    background: rgba(0,0,0,.22);
    border-radius: 16px;
    padding: 12px;
  }
  .section h2{
    margin:0 0 8px 0;
    font-size: 12px;
    letter-spacing: .08em;
    text-transform: uppercase;
    color: var(--muted);
  }
  .desc{
    color: var(--text);
    line-height:1.35;
    font-size: 14px;
  }
  .smallnote{
    color: var(--muted2);
    font-size: 12px;
    margin-top: 6px;
  }
  table{
    width:100%;
    border-collapse: collapse;
    font-size: 14px;
  }
  th, td{
    padding: 10px 8px;
    border-bottom: 1px solid rgba(255,255,255,.10);
    vertical-align: top;
  }
  th{
    text-align:left;
    color: var(--muted);
    font-weight: 600;
  }
  .status{font-weight:700;}
  .entry{color: #86efac;}
  .target{color: #34d399;}
  .emerging{color: #fbbf24;}
  .empty{color: var(--muted2); font-weight: 500;}
  .legend{
    display:flex; gap: 14px; flex-wrap:wrap; align-items:center;
    color: var(--muted);
    font-size: 12px;
  }
  .dot{width:10px;height:10px;border-radius:999px;display:inline-block;margin-right:6px;}
  .dot.entry{background:#86efac;}
  .dot.target{background:#34d399;}
  .dot.emerging{background:#fbbf24;}
  .footer{
    margin-top: 10px;
    color: var(--muted2);
    font-size: 12px;
  }
  a{color:var(--accent); text-decoration:none}
  a:hover{text-decoration:underline}
</style>
</head>
<body>
<div class="shell">
  <div class="grid">
    <div class="card">
      <div class="topbar">
        <select id="modeSel" title="Mode of Communication"></select>
        <select id="skillSel" title="Skill"></select>
        <select id="courseSel" title="Course / Grade"></select>
        <button id="resetBtn" title="Reset view & selection">Reset</button>
        <div class="hint">Drag to rotate ‚Ä¢ Scroll/pinch to zoom ‚Ä¢ Click a slice to ‚Äúpop‚Äù it</div>
      </div>
      <div class="viewer" id="viewer">
        <div class="overlayBadge" id="overlayBadge">Loading data‚Ä¶</div>
      </div>
    </div>

    <div class="card">
      <div class="panel">
        <h1>ACTFL 3D Proficiency Pyramid</h1>
        <div class="sub">Pick a <b>mode</b> + <b>skill</b>, then choose a <b>course</b> (recommended) or click a slice. The pyramid highlights where that course is marked üå± Entry / üåø Target / üå≥ Emerging in the SDC long-sequence chart.</div>

        <div class="chips" id="chips">
          <div class="chip" id="chipSelected">Selected: ‚Äî</div>
          <div class="chip" id="chipMode">Mode: ‚Äî</div>
          <div class="chip" id="chipSkill">Skill: ‚Äî</div>
          <div class="chip" id="chipCourse">Course: ‚Äî</div>
        </div>

        <div class="section">
          <h2>ACTFL Descriptor (short, paraphrased)</h2>
          <div class="desc" id="descBox">Select a course or click a slice.</div>
          <div class="smallnote">These are brief paraphrases to keep the widget readable. You can replace them with your preferred wording or link out to the full ACTFL guidelines PDF.</div>
        </div>

        <div class="section">
          <h2>SDC Expectation at this slice</h2>
          <div class="smallnote" id="expectNote">Only rows with markers at the selected slice are shown.</div>
          <table id="expectTable">
            <thead><tr><th>Course / Grade</th><th>Status</th></tr></thead>
            <tbody><tr><td class="empty" colspan="2">Select a slice.</td></tr></tbody>
          </table>
          <div class="legend" style="margin-top:10px;">
            <span><span class="dot entry"></span>Entry</span>
            <span><span class="dot target"></span>Target</span>
            <span><span class="dot emerging"></span>Emerging</span>
          </div>
        </div>

        <div class="footer">
          Tip: If you want ‚Äúclick course ‚Üí highlight pyramid‚Äù, use the Course dropdown. Clicking a slice is mainly for ‚Äúwhat does this slice represent?‚Äù conversations.
        </div>
      </div>
    </div>
  </div>
</div>

<!-- libs -->
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
<script type="module">
  import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

  // ---------- configuration ----------
  const CSV_URL = "sdclongchart.csv";
  // If you prefer, you can inline the CSV or host it separately. Keeping it as ./file.csv
  // means it lives in the same repo folder as index.html.

  // Level order (low ‚Üí high). SDC chart currently runs N1..A3.
  const LEVELS = [
    { code:"N1", label:"Novice Low" },
    { code:"N2", label:"Novice Mid" },
    { code:"N3", label:"Novice Mid" },
    { code:"N4", label:"Novice High" },
    { code:"I1", label:"Intermediate Low" },
    { code:"I2", label:"Intermediate Mid" },
    { code:"I3", label:"Intermediate Mid" },
    { code:"I4", label:"Intermediate High" },
    { code:"I5", label:"Intermediate High" },
    { code:"A1", label:"Advanced Low" },
    { code:"A2", label:"Advanced Mid" },
    { code:"A3", label:"Advanced High" },
  ];

  // Short, readable descriptors (you can swap these with your own).
  const SHORT_DESC = {
    N1: "Recognizes a few highly familiar words/phrases; relies on repetition and context.",
    N2: "Understands common, practiced language about immediate needs; key words + short phrases.",
    N3: "Understands the main idea in simple, familiar language; still needs support/clarification.",
    N4: "Follows short, simple messages on familiar topics; begins to catch some details.",
    I1: "Understands sentence-length language on familiar topics; can handle predictable speech/text.",
    I2: "Understands connected language on familiar topics; gets main ideas + some supporting details.",
    I3: "Understands the gist and many details in familiar contexts; occasional breakdowns occur.",
    I4: "Understands most routine conversations/texts on familiar topics; can infer meaning sometimes.",
    I5: "Understands extended discourse on familiar topics; manages complications with support.",
    A1: "Understands paragraph-length discourse on concrete topics; can follow organized explanations.",
    A2: "Understands detailed discourse on concrete topics; handles some abstract extensions with help.",
    A3: "Understands extended discourse with nuance; follows arguments and implications with confidence."
  };

  // Mode/Skill display mapping ‚Äî we build these from the CSV section titles.
  let DATA = null; // parsed structure
  let currentMode = null;
  let currentSkill = null;
  let currentCourse = null;
  let selectedLevel = null;

  // ---------- DOM ----------
  const modeSel = document.getElementById("modeSel");
  const skillSel = document.getElementById("skillSel");
  const courseSel = document.getElementById("courseSel");
  const resetBtn = document.getElementById("resetBtn");

  const overlayBadge = document.getElementById("overlayBadge");
  const descBox = document.getElementById("descBox");
  const expectTbody = document.querySelector("#expectTable tbody");
  const chipSelected = document.getElementById("chipSelected");
  const chipMode = document.getElementById("chipMode");
  const chipSkill = document.getElementById("chipSkill");
  const chipCourse = document.getElementById("chipCourse");

  function setChip(el, label, value){
    el.textContent = `${label}: ${value ?? "‚Äî"}`;
  }

  // ---------- CSV parsing ----------
  function normalize(s){
    return (s||"").toString().trim();
  }

  function detectStatus(cell){
    const t = normalize(cell);
    if(!t) return null;
    // supports either emoji labels or plain text
    const lower = t.toLowerCase();
    if(lower.includes("entry")) return "Entry";
    if(lower.includes("target")) return "Target";
    if(lower.includes("emerging")) return "Emerging";
    // some cells may just be emoji
    if(t.includes("üå±")) return "Entry";
    if(t.includes("üåø")) return "Target";
    if(t.includes("üå≥")) return "Emerging";
    return null;
  }

  function parseChart(rows){
    // We expect the first non-empty row to be the level-code row: N1, N2, N3...
    // The first column is the row label. Remaining columns are levels.
    const headerRow = rows.find(r => Object.values(r).some(v => normalize(v)==="N1"));
    if(!headerRow) throw new Error("Could not find the level-code row (N1, N2, ‚Ä¶) in the CSV.");

    const cols = Object.keys(headerRow);
    const labelCol = cols[0];
    const levelCols = cols.slice(1);

    // Map CSV columns ‚Üí level codes using that header row
    const colToCode = {};
    for(const c of levelCols){
      const code = normalize(headerRow[c]);
      if(code) colToCode[c] = code;
    }

    // Build sections
    // Convention used in your file:
    // - rows with "‚Äî Full Spectrum" are skill descriptor rows
    // - subsequent rows are courses/grades until next "‚Äî Full Spectrum"
    const sections = [];
    let current = null;

    for(const r of rows){
      const label = normalize(r[labelCol]);
      if(!label) continue;
      const isSkillRow = label.includes("Full Spectrum") || label.includes("FULL SPECTRUM");
      const isModeRow = /COMMUNICATION/i.test(label) && label.includes("-");
      if(isModeRow){
        // Mode header row (e.g., "INTERPRETIVE COMMUNICATION - (Listening & Reading)")
        // We'll store it and keep going.
        // No action besides remembering for upcoming skills
        continue;
      }
      if(isSkillRow){
        current = {
          skillTitle: label,
          descriptors: {},   // code -> text (from this row)
          courses: []          // { name, marks: {code->status} }
        };
        // descriptors live on this same row
        for(const c of Object.keys(colToCode)){
          const code = colToCode[c];
          const txt = normalize(r[c]);
          if(txt) current.descriptors[code] = txt;
        }
        sections.push(current);
        continue;
      }

      // Otherwise a course row, attach to current skill
      if(current){
        const marks = {};
        for(const c of Object.keys(colToCode)){
          const code = colToCode[c];
          const status = detectStatus(r[c]);
          if(status) marks[code] = status;
        }
        current.courses.push({ name: label, marks });
      }
    }

    // Now infer Mode from section titles
    // We do a simple heuristic based on keywords in skillTitle.
    const modeBuckets = {
      "Interpretive Communication": [],
      "Interpersonal Communication": [],
      "Presentational Communication": [],
    };

    for(const s of sections){
      const t = s.skillTitle.toLowerCase();
      let mode = "Interpretive Communication";
      if(t.includes("interpersonal")) mode = "Interpersonal Communication";
      else if(t.includes("presentational")) mode = "Presentational Communication";
      s.mode = mode;

      // Skill name: strip "‚Äì Full Spectrum"
      s.skill = s.skillTitle.replace(/\s*[‚Äì-]\s*Full Spectrum\s*/i, "").trim();
      modeBuckets[mode].push(s);
    }

    // Courses list (global) to populate dropdown, but we want per-skill selection too.
    return {
      labelCol,
      colToCode,
      sections,
      modeBuckets,
    };
  }

  async function loadCSV(){
    overlayBadge.textContent = "Loading proficiency chart‚Ä¶";
    return new Promise((resolve, reject) => {
      Papa.parse(CSV_URL, {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: (res) => {
          try {
            const data = res.data || [];
            resolve(parseChart(data));
          } catch(e) {
            reject(e);
          }
        },
        error: (err) => reject(err)
      });
    });
  }

  // ---------- THREE scene ----------
  let scene, camera, renderer, controls, raycaster, pointer;
  let group; // pyramid group
  let slices = []; // {mesh, code, idx, baseY}
  let exploded = new Set(); // codes exploded
  let highlightCodes = new Set(); // highlighted from course selection

  const COLORS = {
    Novice: 0x3b82f6,
    Intermediate: 0x22c55e,
    Advanced: 0xf97316
  };

  function bandFor(code){
    if(code.startsWith("N")) return "Novice";
    if(code.startsWith("I")) return "Intermediate";
    if(code.startsWith("A")) return "Advanced";
    return "Other";
  }

  function createScene(container){
    scene = new THREE.Scene();

    const w = container.clientWidth;
    const h = container.clientHeight;

    camera = new THREE.PerspectiveCamera(42, w/h, 0.1, 100);
    camera.position.set(0, 2.2, 5.2);

    renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(w, h);
    container.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 2.6;
    controls.maxDistance = 9.0;
    controls.target.set(0, 1.3, 0);

    raycaster = new THREE.Raycaster();
    pointer = new THREE.Vector2();

    const ambient = new THREE.AmbientLight(0xffffff, 0.65);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 0.9);
    key.position.set(3, 5, 3);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0xffffff, 0.35);
    rim.position.set(-4, 2, -3);
    scene.add(rim);

    // subtle floor shadow-ish
    const floorGeo = new THREE.CircleGeometry(1.4, 64);
    const floorMat = new THREE.MeshBasicMaterial({ color:0x1b2a5c, transparent:true, opacity:0.55 });
    const floor = new THREE.Mesh(floorGeo, floorMat);
    floor.rotation.x = -Math.PI/2;
    floor.position.y = 0.05;
    scene.add(floor);

    window.addEventListener("resize", () => {
      const nw = container.clientWidth, nh = container.clientHeight;
      camera.aspect = nw/nh;
      camera.updateProjectionMatrix();
      renderer.setSize(nw, nh);
    });

    renderer.domElement.addEventListener("pointermove", (e)=>onPointerMove(e, container));
    renderer.domElement.addEventListener("pointerdown", (e)=>onPointerDown(e, container));
  }

  function radiiForIdx(idx){
    // low‚Üíhigh increases radius; we want an *inverted pyramid look* (wider at the top),
    // so we place N1 at bottom (small) and A3 at top (large).
    const t = idx/(LEVELS.length-1); // 0..1
    const r = 0.18 + t*1.35; // radius scale
    return r;
  }

  function buildPyramid(){
    if(group) scene.remove(group);
    group = new THREE.Group();
    slices = [];

    const height = 2.7;
    const sliceH = height / LEVELS.length;
    const y0 = 0.2;

    // Build from bottom (idx 0 = N1) upward
    for(let i=0;i<LEVELS.length;i++){ 
      const c = LEVELS[i].code;
      const r1 = radiiForIdx(i);
      const r2 = radiiForIdx(i+1); // next level
      const topR = (i===LEVELS.length-1) ? r1*1.04 : r2;
      const botR = r1;
      const geo = new THREE.CylinderGeometry(topR, botR, sliceH, 48, 1, true);
      geo.translate(0, y0 + sliceH*(i+0.5), 0);

      const band = bandFor(c);
      const mat = new THREE.MeshStandardMaterial({
        color: COLORS[band] ?? 0x9ca3af,
        metalness: 0.15,
        roughness: 0.45,
        transparent: true,
        opacity: 0.92,
        emissive: 0x000000,
        emissiveIntensity: 0.65
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData = { code: c, idx: i };
      group.add(mesh);

      // label sprite (CSS2D would be nicer, but keep it simple: we render labels in overlay chips)
      slices.push({ mesh, code: c, idx: i, baseY: y0 + sliceH*(i+0.5) });
    }

    // wireframe outline for context
    const outlineGeo = new THREE.CylinderGeometry(radiiForIdx(LEVELS.length-1)*1.06, radiiForIdx(0)*0.98, height, 36, 1, true);
    const outlineMat = new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.10, wireframe:true });
    const outline = new THREE.Mesh(outlineGeo, outlineMat);
    outline.position.y = y0 + height/2;
    group.add(outline);

    scene.add(group);
    applyHighlights();
  }

  function applyHighlights(){
    for(const s of slices){
      const band = bandFor(s.code);
      const baseColor = COLORS[band] ?? 0x9ca3af;
      const mat = s.mesh.material;
      mat.color.setHex(baseColor);

      // highlighted slices glow slightly and get higher opacity
      const isHi = highlightCodes.has(s.code);
      mat.emissive.setHex(isHi ? 0x1e40af : 0x000000);
      mat.opacity = isHi ? 1.0 : 0.84;

      // selected slice: stronger glow
      if(selectedLevel === s.code){
        mat.emissive.setHex(0xffffff);
        mat.opacity = 1.0;
      }
    }
  }

  function setExplode(code, on){
    if(on) exploded.add(code);
    else exploded.delete(code);
  }

  function animateExplode(){
    // Explode effect: each exploded slice moves upward by a small gap proportional to its index,
    // leaving visible separations like magnetized 3D printed pieces.
    const gap = 0.09;
    for(const s of slices){
      const targetY = s.baseY + (exploded.has(s.code) ? gap*(s.idx+1) : 0);
      // Smooth lerp
      const mesh = s.mesh;
      const currentY = mesh.position.y;
      mesh.position.y += (targetY - currentY) * 0.18;
    }
  }

  function onPointerMove(e, container){
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObjects(group.children, false);
    renderer.domElement.style.cursor = hits.length ? "pointer" : "grab";
  }

  function onPointerDown(e, container){
    const rect = renderer.domElement.getBoundingClientRect();
    pointer.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    pointer.y = -(((e.clientY - rect.top) / rect.height) * 2 - 1);

    raycaster.setFromCamera(pointer, camera);
    const hits = raycaster.intersectObjects(group.children, false);
    if(!hits.length) return;

    const hit = hits[0].object;
    const code = hit.userData?.code;
    if(!code) return;

    // Toggle explode + set selected
    selectedLevel = code;
    setExplode(code, !exploded.has(code));
    syncUIFromSelection();
  }

  function resetView(){
    exploded.clear();
    selectedLevel = null;
    highlightCodes.clear();
    controls.reset();
    controls.target.set(0,1.3,0);
    camera.position.set(0,2.2,5.2);
    currentCourse = null;
    courseSel.value = "";
    syncUIFromSelection();
  }

  // ---------- UI logic ----------
  function setOptions(select, items, placeholder){
    select.innerHTML = "";
    const opt0 = document.createElement("option");
    opt0.value = "";
    opt0.textContent = placeholder;
    select.appendChild(opt0);
    for(const it of items){
      const opt = document.createElement("option");
      opt.value = it.value;
      opt.textContent = it.label;
      select.appendChild(opt);
    }
  }

  function ensureModeSkillDefaults(){
    if(!currentMode) currentMode = Object.keys(DATA.modeBuckets)[0];
    const skills = DATA.modeBuckets[currentMode] || [];
    if(!currentSkill) currentSkill = skills[0]?.skill;
    if(currentSkill && !skills.some(s => s.skill === currentSkill)){
      currentSkill = skills[0]?.skill;
    }
  }

  function getSection(){
    if(!DATA) return null;
    const skills = DATA.modeBuckets[currentMode] || [];
    return skills.find(s => s.skill === currentSkill) || null;
  }

  function populateModeSkill(){
    ensureModeSkillDefaults();

    setOptions(modeSel,
      Object.keys(DATA.modeBuckets).map(m => ({ value:m, label:m })),
      "Select mode‚Ä¶"
    );
    modeSel.value = currentMode;

    const skills = (DATA.modeBuckets[currentMode] || []).map(s => ({ value:s.skill, label:s.skill }));
    setOptions(skillSel, skills, "Select skill‚Ä¶");
    skillSel.value = currentSkill || "";
  }

  function populateCourses(){
    const section = getSection();
    const courses = (section?.courses || []).map(c => ({ value:c.name, label:c.name }));
    setOptions(courseSel, courses, "Select course/grade‚Ä¶");
    courseSel.value = currentCourse || "";
  }

  function levelsForCourse(courseName){
    const section = getSection();
    if(!section) return {};
    const row = section.courses.find(c => c.name === courseName);
    return row?.marks || {};
  }

  function selectCourse(courseName){
    currentCourse = courseName || null;
    highlightCodes.clear();

    if(currentCourse){
      const marks = levelsForCourse(currentCourse);
      Object.keys(marks).forEach(code => highlightCodes.add(code));
      // auto-select the highest marked slice as default selection
      const marked = Object.keys(marks);
      if(marked.length){
        const highest = marked.sort((a,b)=>LEVELS.findIndex(x=>x.code===a)-LEVELS.findIndex(x=>x.code===b)).slice(-1)[0];
        selectedLevel = highest;
      }
    }
    syncUIFromSelection();
  }

  function syncUIFromSelection(){
    const section = getSection();
    overlayBadge.textContent = section ? `Mode: ${currentMode} ‚Ä¢ Skill: ${currentSkill}` : "No data loaded";
    setChip(chipMode, "Mode", currentMode);
    setChip(chipSkill, "Skill", currentSkill);
    setChip(chipCourse, "Course", currentCourse || "‚Äî");

    const levelLabel = selectedLevel
      ? `${selectedLevel} (${LEVELS.find(l=>l.code===selectedLevel)?.label || "‚Äî"})`
      : "‚Äî";
    setChip(chipSelected, "Selected", levelLabel);

    // descriptor box: prefer chart descriptor text, else short paraphrase
    if(selectedLevel){
      const long = section?.descriptors?.[selectedLevel];
      const short = SHORT_DESC[selectedLevel] || "‚Äî";
      descBox.textContent = long ? long : short;
    } else {
      descBox.textContent = "Select a course or click a slice.";
    }

    // expectation table: show all courses that have a mark at selectedLevel
    expectTbody.innerHTML = "";
    if(!selectedLevel || !section){
      const tr = document.createElement("tr");
      const td = document.createElement("td");
      td.colSpan = 2;
      td.className = "empty";
      td.textContent = "Select a slice.";
      tr.appendChild(td);
      expectTbody.appendChild(tr);
    } else {
      const rows = [];
      for(const c of section.courses){
        const status = c.marks[selectedLevel];
        if(status){
          rows.push({ course:c.name, status });
        }
      }
      if(!rows.length){
        const tr = document.createElement("tr");
        const td = document.createElement("td");
        td.colSpan = 2;
        td.className = "empty";
        td.textContent = "No courses are marked at this slice in the chart.";
        tr.appendChild(td);
        expectTbody.appendChild(tr);
      } else {
        for(const r of rows){
          const tr = document.createElement("tr");
          const td1 = document.createElement("td");
          td1.textContent = r.course;
          const td2 = document.createElement("td");
          td2.className = "status " + (r.status.toLowerCase());
          td2.textContent = r.status;
          tr.appendChild(td1); tr.appendChild(td2);
          expectTbody.appendChild(tr);
        }
      }
    }

    applyHighlights();

    // If a course is selected, gently ‚Äúexplode‚Äù all highlighted slices for a magnet-like feel.
    exploded.clear();
    if(currentCourse){
      for(const code of highlightCodes){
        exploded.add(code);
      }
    }
  }

  // ---------- main ----------
  async function main(){
    try {
      DATA = await loadCSV();
      // Default to Interpretive + Interpretive Reading if available; else first mode/skill.
      currentMode = "Interpretive Communication";
      const maybe = DATA.modeBuckets[currentMode]?.find(s => /reading/i.test(s.skill));
      currentSkill = maybe?.skill || DATA.modeBuckets[currentMode]?.[0]?.skill;

      populateModeSkill();
      populateCourses();

      // Setup 3D
      const container = document.getElementById("viewer");
      createScene(container);
      buildPyramid();

      overlayBadge.textContent = "Ready.";
      syncUIFromSelection();

      // events
      modeSel.addEventListener("change", () => {
        currentMode = modeSel.value || currentMode;
        currentSkill = null;
        currentCourse = null;
        selectedLevel = null;
        highlightCodes.clear();
        populateModeSkill();
        populateCourses();
        syncUIFromSelection();
      });
      skillSel.addEventListener("change", () => {
        currentSkill = skillSel.value || currentSkill;
        currentCourse = null;
        selectedLevel = null;
        highlightCodes.clear();
        populateCourses();
        syncUIFromSelection();
      });
      courseSel.addEventListener("change", () => {
        selectCourse(courseSel.value);
      });
      resetBtn.addEventListener("click", resetView);

      // render loop
      function tick(){
        controls.update();
        animateExplode();
        renderer.render(scene, camera);
        requestAnimationFrame(tick);
      }
      tick();

    } catch(e) {
      console.error(e);
      overlayBadge.textContent = "Error loading chart. See console.";
      descBox.textContent = "Could not load the CSV. Make sure the CSV file is in the same GitHub repo folder as index.html and that the filename matches exactly.";
    }
  }

  main();
</script>
</body>
</html>
